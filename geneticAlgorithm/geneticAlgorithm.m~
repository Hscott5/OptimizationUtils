function history = geneticAlgorithm(varargin)

p = inputParser;
defaultDims = 128;
nParticles = 64;
defaultRadius = 15;
addParameter(p, 'nDims', defaultDims, @isnumeric);
addParameter(p, 'nParticles', nParticles);
addParameter(p, 'startRadius', defaultRadius);
addParameter(p, 'optimizeFor', 'norm');
addParameter(p, 'nKeep', 16); % # of unaltered vectors to keep for next gen
addOptional(p,'history', struct('oldVelocity', 0));
p.StructExpand = false;
parse(p, varargin{:});
history = p.Results.history;
nDims = p.Results.nDims;
optimizeFor = p.Results.optimizeFor;
startRadius = p.Results.startRadius;


if ~isfield(history, 'stim')
    history.stim = {normc(randn(nDims,nParticles)).*startRadius};
    history.nChild = p.Results.nParticles-p.Results.nKeep;
    return
end

%% Update Population Best and Personal Best Values

switch optimizeFor
    case 'norm'
        norms = sqrt(sum(history.response{end}.^2, 1));
        sorted = sort(norms);
        winner = find(norms==sorted(end)); % index of latent with best response this generation
        % if it's a tie, ignore one (maybe later add in new function to keep more than one globalBest)
        if size(winner, 2)>1
            winner = winner(:,1);
        end
        % initialize these fields with the only available values
        if ~isfield(history, 'globalBest')
            history.globalBest = {history.stim{end}(:,winner); history.response{end}(:,winner)};
            history.personalBest = {history.stim{end}; history.response{end}};  
        end
        % if any new best guesses appear, save them
        if norm(history.globalBest{2}(:,end)) < norms(winner)
            history.globalBest{1,:} = cat(2, history.globalBest{1,:}, history.stim{end}(:,winner));
            history.globalBest{2,:} = cat(2, history.globalBest{2,:}, history.response{end}(:,winner));
        end
        % save any changes to the personal best guess
        personalNorms = sqrt(sum(history.personalBest{2}.^2,1));
        particleImproveIndx = norms > personalNorms(:,:,end);
        newPersonalBests = history.personalBest{1}(:,:,end);
        newPersonalBestResponses = history.personalBest{2}(:,:,end);
        newPersonalBests(:,particleImproveIndx) = history.stim{end}(:,particleImproveIndx);
        newPersonalBestResponses(:,particleImproveIndx) = history.response{end}(:,particleImproveIndx);
        if min(size(newPersonalBests))~=0
            history.personalBest{1,:} = cat(3, history.personalBest{1,:}, newPersonalBests);
            history.personalBest{2,:} = cat(3, history.personalBest{2,:}, newPersonalBestResponses);
        end
    case 'variance'
        vars = var(history.response{end});
        sorted = sort(vars);
        winner = find(vars==sorted(end)); % index of latent with best response this generation
        % if it's a tie, ignore one (maybe later add in new function to keep more than one globalBest)
        if size(winner, 2)>1
            winner = winner(:,1);
        end
         % initialize these fields with the only available values
        if ~isfield(history, 'globalBest')
            history.globalBest = {history.stim{end}(:,winner); history.response{end}(:,winner)};
            history.personalBest = {history.stim{end}; history.response{end}};  
        end
        
        % if any new best guesses appear, save them
        if var(history.globalBest{2}(:,end)) < vars(winner)
            history.globalBest{1,:} = cat(2, history.globalBest{1,:}, history.stim{end}(:,winner));
            history.globalBest{2,:} = cat(2, history.globalBest{2,:}, history.response{end}(:,winner));
        end
        personalBestVars = var(history.personalBest{2}); % personal best variances
        particleImproveIndx = vars > personalBestVars(:,:,end);
        % preallocate
        newPersonalBests = history.personalBest{1}(:,:,end); 
        newPersonalBestResponses = history.personalBest{2}(:,:,end);
        % replace with new personal bests
        newPersonalBests(:,particleImproveIndx) = history.stim{end}(:,particleImproveIndx);
        newPersonalBestResponses(:,particleImproveIndx) = history.response{end}(:,particleImproveIndx);
        % save history of old personal bests
        if min(size(newPersonalBests))~=0
            history.personalBest{1,:} = cat(3, history.personalBest{1,:}, newPersonalBests);
            history.personalBest{2,:} = cat(3, history.personalBest{2,:}, newPersonalBestResponses);
        end
end

%% Generate Next set of latents


% zscore firing rates within generation
%   then scale with "selectiveness factor" of 0.5
%   then pass through a softmax function to make them probabilities
% = fitness

% keep top 10 unaltered
%   add 30 "children" by recombining from last generation
%   probability of being a parent = fitness
%   parents contribute unevenly 75%/25%
%   then children genes mutate at 25% rate
%    - mutations drawn from 0-centered Gaussian with sig 0.75

% 70-200ms time window after stim onset

fit = calcFitness(history.response{end});

bestInd = sort(fit, 'descend');
vecs2Keep = history.stim{end}(:,ismember(fit, bestInd(1:nKeep)));

%% Make Babies

children = recombine(history.stim{end},history.nChild, fit); % fit=probability of being a parent

children = mutate(children);

%% Add next generation to history

allVecs = [vecs2Keep, children];
history.stim{end+1} = allVecs(:, randperm(size(allVecs,2)));







